04/05 = falta crear las rutas, configurar las rutas de vistas y amoldar con los controladores de sessions.

¡Genial que el login esté funcionando! Tu aplicación de turnero para un consultorio ya tiene una base sólida con autenticación de usuarios y roles (admin y usuario). Ahora, para avanzar en el desarrollo, necesitas enfocarte en las funcionalidades clave del sistema, como la gestión de turnos, la interfaz de usuario y la lógica del backend para soportar estas operaciones. A continuación, te sugiero un plan para continuar, considerando si priorizar el frontend o el backend, junto con referencias y recomendaciones específicas para una aplicación de turnero.
Evaluación: ¿Frontend o Backend?
Dado que tu aplicación ya tiene un sistema de autenticación funcional y una estructura básica de rutas en el frontend (Login y Home), te recomiendo dividir el trabajo en etapas, alternando entre backend y frontend, pero con un enfoque inicial en el backend para definir la lógica y los endpoints necesarios para la gestión de turnos. Esto te permitirá:
Establecer la funcionalidad core (crear, listar, modificar y cancelar turnos) en el backend, lo que es esencial para un turnero.

Construir el frontend una vez que los endpoints estén listos, asegurando que la interfaz se conecte correctamente con la API.

Iterar entre ambos para ajustar la experiencia del usuario y agregar funcionalidades avanzadas.

Razón para empezar por el backend:
La gestión de turnos requiere un modelo de datos (por ejemplo, citas con fecha, hora, paciente, doctor, etc.), validaciones (evitar conflictos de horarios) y operaciones CRUD (crear, leer, actualizar, eliminar). Estas lógicas son más fáciles de implementar y probar primero en el backend.

Una vez que los endpoints estén definidos, el frontend puede consumirlos directamente, reduciendo la necesidad de reescribir código en el frontend si cambian los requisitos.

Razón para trabajar en el frontend después:
El frontend dependerá de los datos que el backend proporcione. Por ejemplo, mostrar un calendario de turnos o un formulario para reservar un turno requiere que los endpoints devuelvan datos en un formato específico.

Puedes diseñar la interfaz de usuario (UI) para que sea intuitiva para pacientes y administradores, pero primero necesitas la lógica del backend para probarla.

Plan de Desarrollo
1. Backend: Modelo y Endpoints para Turnos
Objetivo: Implementar la lógica para gestionar turnos (reservar, listar, modificar, cancelar) y definir roles (admin puede gestionar todos los turnos, usuarios solo los suyos).
Pasos:
Modelo de Turnos:
Crea un modelo en MongoDB para los turnos (appointments.model.js) con campos como:
javascript

import mongoose from 'mongoose';

const collection = 'appointments';

const schema = new mongoose.Schema({
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'users', required: true }, // Referencia al usuario/paciente
    doctor: { type: String, required: true }, // Nombre o ID del doctor
    date: { type: Date, required: true }, // Fecha y hora del turno
    status: { type: String, enum: ['pending', 'confirmed', 'cancelled'], default: 'pending' },
    notes: { type: String }, // Notas opcionales
});

const appointmentsModel = mongoose.model(collection, schema);
export default appointmentsModel;

DAO para Turnos:
Crea un appointments.dao.js para manejar operaciones CRUD:
javascript

import appointmentsModel from '../models/appointments.model.js';

class AppointmentsDAO {
    async createAppointment(appointmentData) {
        const appointment = new appointmentsModel(appointmentData);
        return await appointment.save();
    }

    async findAppointmentsByUser(userId) {
        return await appointmentsModel.find({ user: userId }).populate('user');
    }

    async findAllAppointments() {
        return await appointmentsModel.find().populate('user');
    }

    async updateAppointment(id, updateData) {
        return await appointmentsModel.findByIdAndUpdate(id, updateData, { new: true });
    }

    async deleteAppointment(id) {
        return await appointmentsModel.findByIdAndDelete(id);
    }
}

export default AppointmentsDAO;

Controlador y Rutas:
Crea un controlador (appointments.controller.js) con funciones para manejar las solicitudes:
javascript

import AppointmentsDAO from '../services/dao/appointments.dao.js';
import { passportCall, authorization } from '../middlewares/auth.js';

const AppointmentsDAO = new AppointmentsDAO();

export const createAppointment = async (req, res) => {
    try {
        const { doctor, date, notes } = req.body;
        if (!doctor || !date) {
            return res.status(400).json({ message: 'Faltan datos requeridos' });
        }

        // Validar que no haya conflicto de horario
        const existingAppointment = await AppointmentsDAO.findAllAppointments()
            .find(app => app.doctor === doctor && app.date.getTime() === new Date(date).getTime());
        if (existingAppointment) {
            return res.status(400).json({ message: 'El horario ya está ocupado' });
        }

        const appointment = await AppointmentsDAO.createAppointment({
            user: req.user.id,
            doctor,
            date: new Date(date),
            notes,
        });
        res.status(201).json(appointment);
    } catch (error) {
        res.status(500).json({ message: 'Error al crear el turno', error });
    }
};

export const getUserAppointments = async (req, res) => {
    try {
        const appointments = await AppointmentsDAO.findAppointmentsByUser(req.user.id);
        res.status(200).json(appointments);
    } catch (error) {
        res.status(500).json({ message: 'Error al obtener turnos', error });
    }
};

export const getAllAppointments = async (req, res) => {
    try {
        const appointments = await AppointmentsDAO.findAllAppointments();
        res.status(200).json(appointments);
    } catch (error) {
        res.status(500).json({ message: 'Error al obtener turnos', error });
    }
};

export const updateAppointment = async (req, res) => {
    try {
        const { id } = req.params;
        const updateData = req.body;
        const appointment = await AppointmentsDAO.updateAppointment(id, updateData);
        if (!appointment) {
            return res.status(404).json({ message: 'Turno no encontrado' });
        }
        res.status(200).json(appointment);
    } catch (error) {
        res.status(500).json({ message: 'Error al actualizar turno', error });
    }
};

export const deleteAppointment = async (req, res) => {
    try {
        const { id } = req.params;
        const appointment = await AppointmentsDAO.deleteAppointment(id);
        if (!appointment) {
            return res.status(404).json({ message: 'Turno no encontrado' });
        }
        res.status(200).json({ message: 'Turno eliminado' });
    } catch (error) {
        res.status(500).json({ message: 'Error al eliminar turno', error });
    }
};

Define rutas en appointments.router.js:
javascript

import { Router } from 'express';
import { createAppointment, getUserAppointments, getAllAppointments, updateAppointment, deleteAppointment } from '../controllers/appointments.controller.js';
import { passportCall, authorization } from '../middlewares/auth.js';

const router = Router();

router.post('/', passportCall('jwt'), createAppointment); // Crear turno (autenticado)
router.get('/user', passportCall('jwt'), getUserAppointments); // Listar turnos del usuario
router.get('/', passportCall('jwt'), authorization('admin'), getAllAppointments); // Listar todos los turnos (solo admin)
router.put('/:id', passportCall('jwt'), updateAppointment); // Actualizar turno
router.delete('/:id', passportCall('jwt'), deleteAppointment); // Cancelar turno

export default router;

Registra el router en app.js:
javascript

app.use('/api/appointments', appointmentsRouter);

Referencias:
Mongoose Documentation para modelado de datos.

Express Routing para crear endpoints.

Passport JWT Strategy para autenticación.

2. Frontend: Interfaz para Gestionar Turnos
Objetivo: Crear componentes para que los usuarios reserven turnos y los administradores gestionen todos los turnos.
Pasos:
Componente para Reservar Turnos:
Crea un componente BookAppointment.jsx con un formulario para seleccionar doctor, fecha y hora:
jsx

import React, { useState } from 'react';
import axios from '../../api/axios.api.jsx';
import { useNavigate } from 'react-router-dom';

const BookAppointment = () => {
    const navigate = useNavigate();
    const [form, setForm] = useState({
        doctor: '',
        date: '',
        notes: '',
    });

    const handleChange = (e) => {
        setForm({ ...form, [e.target.name]: e.target.value });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/appointments', form);
            alert('Turno reservado con éxito');
            navigate('/appointments');
        } catch (error) {
            alert('Error al reservar turno: ' + (error.response?.data?.message || 'Error desconocido'));
        }
    };

    return (
        <div>
            <h2>Reservar Turno</h2>
            <form onSubmit={handleSubmit}>
                <select name="doctor" onChange={handleChange} required>
                    <option value="">Seleccionar Doctor</option>
                    <option value="Dr. Smith">Dr. Smith</option>
                    <option value="Dr. Johnson">Dr. Johnson</option>
                </select>
                <input
                    type="datetime-local"
                    name="date"
                    value={form.date}
                    onChange={handleChange}
                    required
                />
                <textarea
                    name="notes"
                    placeholder="Notas"
                    value={form.notes}
                    onChange={handleChange}
                />
                <button type="submit">Reservar</button>
            </form>
        </div>
    );
};

export default BookAppointment;

Componente para Listar Turnos:
Crea un componente AppointmentsList.jsx para mostrar los turnos del usuario o todos los turnos (si es admin):
jsx

import React, { useState, useEffect } from 'react';
import axios from '../../api/axios.api.jsx';
import { useSearchParams } from 'react-router-dom';

const AppointmentsList = () => {
    const [appointments, setAppointments] = useState([]);
    const [searchParams] = useSearchParams();
    const role = searchParams.get('role');

    useEffect(() => {
        const fetchAppointments = async () => {
            try {
                const endpoint = role === 'admin' ? '/appointments' : '/appointments/user';
                const { data } = await axios.get(endpoint);
                setAppointments(data);
            } catch (error) {
                console.error('Error fetching appointments:', error);
            }
        };
        fetchAppointments();
    }, [role]);

    return (
        <div>
            <h2>{role === 'admin' ? 'Todos los Turnos' : 'Mis Turnos'}</h2>
            <ul>
                {appointments.map((appointment) => (
                    <li key={appointment._id}>
                        {appointment.doctor} - {new Date(appointment.date).toLocaleString()} - {appointment.status}
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default AppointmentsList;

Actualizar Rutas:
Modifica App.jsx para incluir las nuevas rutas:
jsx

import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Login from './components/login/login';
import Home from './components/home/home';
import BookAppointment from './components/appointments/BookAppointment';
import AppointmentsList from './components/appointments/AppointmentsList';

function App() {
    return (
        <Router>
            <Routes>
                <Route path="/" element={<Login />} />
                <Route path="/home" element={<Home />} />
                <Route path="/book-appointment" element={<BookAppointment />} />
                <Route path="/appointments" element={<AppointmentsList />} />
            </Routes>
        </Router>
    );
}

export default App;

Mejorar la UI:
Usa una librería como Material-UI o Ant Design para estilizar los formularios y listas.

Integra un calendario (por ejemplo, React Big Calendar) para mostrar los turnos visualmente:
bash

npm install react-big-calendar

Ejemplo de uso:
jsx

import { Calendar, momentLocalizer } from 'react-big-calendar';
import moment from 'moment';
import 'react-big-calendar/lib/css/react-big-calendar.css';

const localizer = momentLocalizer(moment);

const MyCalendar = ({ appointments }) => (
    <Calendar
        localizer={localizer}
        events={appointments.map((app) => ({
            title: app.doctor,
            start: new Date(app.date),
            end: new Date(app.date),
        }))}
        startAccessor="start"
        endAccessor="end"
        style={{ height: 500 }}
    />
);

Referencias:
React Router para manejar rutas.

Material-UI para componentes de UI.

React Big Calendar para calendarios.

Axios para solicitudes HTTP.

3. Funcionalidades Avanzadas
Objetivo: Agregar características que mejoren la usabilidad y escalabilidad.
Notificaciones: Implementa notificaciones por email o SMS para confirmar turnos usando servicios como Nodemailer o Twilio.

Validaciones de Horario: Asegúrate de que los turnos respeten los horarios laborales (por ejemplo, 9:00-17:00) y evita solapamientos.

Panel de Administración: Crea un componente para que los administradores gestionen doctores, horarios y turnos.

Historial de Turnos: Permite a los usuarios ver un historial de turnos pasados.

Recomendaciones Generales
Itera entre Backend y Frontend:
Implementa un endpoint en el backend (por ejemplo, crear turno), pruébalo con Postman, luego crea el componente correspondiente en el frontend.

Usa herramientas como Postman o Thunder Client para probar los endpoints.

Pruebas:
Escribe pruebas unitarias para el backend con Jest y Supertest.

Prueba el frontend con React Testing Library.

Seguridad:
Asegúrate de que los endpoints estén protegidos con passportCall('jwt') y authorization('admin') donde corresponda.

Valida todas las entradas en el backend para evitar inyecciones o datos inválidos.

Escalabilidad:
Considera agregar un modelo para doctores (doctors.model.js) con horarios disponibles.

Usa índices en MongoDB para optimizar consultas frecuentes (por ejemplo, buscar turnos por fecha).

Referencias Adicionales
Tutoriales:
Build a REST API with Node.js and Express para profundizar en el backend.

React CRUD App with Axios para conectar frontend y backend.

Proyectos de Ejemplo:
GitHub: Appointment Booking System para inspiración.

MERN Stack Appointment App para un proyecto completo.

Librerías Útiles:
Moment.js o date-fns para manejar fechas.

React Query para gestionar solicitudes HTTP y caché.

Próximos Pasos Inmediatos
Backend: Crea el modelo, DAO, controlador y rutas para los turnos como se describió en la sección 1.

Prueba los Endpoints: Usa Postman para verificar que puedes crear y listar turnos.

Frontend: Implementa el componente BookAppointment.jsx y conéctalo al endpoint /appointments.

Itera: Agrega el componente AppointmentsList.jsx y prueba la funcionalidad completa.

Este enfoque te permitirá avanzar de manera estructurada, completando las funcionalidades principales del turnero mientras mantienes el código organizado. Si necesitas ayuda con algún componente específico o encuentras un error, comparte los detalles y te asistiré. ¡Buena suerte con tu proyecto!

